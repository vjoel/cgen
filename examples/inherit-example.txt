
The generated code looks, in part, as follows. Note that CGenerator/CShadow produces quite readable C code. In the Parent.h header file we have:

  typedef struct Parent_Shadow {
      VALUE self;
      VALUE ruby_str; // String;
      int c_int;
  } Parent_Shadow;

  typedef struct Child_Shadow {

      /* Parent_Shadow members */
      VALUE self;
      VALUE ruby_str; // String;
      int c_int;

      VALUE obj; // Object;
  } Child_Shadow;

Again, members are duplicated, which would be awful if you wanted to manually maintain the code, but who wants to do that :-)

In the Parent.c file, we have:

  void mark_Parent_Shadow(Parent_Shadow *shadow)
  {
      rb_gc_mark((void *)shadow->self);
      rb_gc_mark((void *)shadow->ruby_str);
  }

  void mark_Child_Shadow(Child_Shadow *shadow)
  {
      rb_gc_mark((void *)shadow->self);
      rb_gc_mark((void *)shadow->ruby_str);
      rb_gc_mark((void *)shadow->obj);
  }

and similarly for the free functions, persistence functions, etc. The #new method generated by CShadow is where rb_obj_call_init() gets called. Note that initialization of shadow attributes is customizable.

  VALUE new_module_Child_singleton_method(int argc, VALUE *argv, VALUE self)
  {
      VALUE object;
      Child_Shadow *shadow;

      object = Data_Make_Struct(self,
                 Child_Shadow,
                 mark_Child_Shadow,
                 free_Child_Shadow,
                 shadow);
      shadow->self = object;

      shadow->ruby_str = Qnil;
      shadow->obj = Qnil;

      rb_obj_call_init(object, argc, argv);

      return object;
  }

The #ruby_str= method only needs to be defined for Parent, because, of course, Ruby itself handles inheritance of methods. Note the type checking, which is done for the ruby_str member but not for the obj member.

  VALUE ruby__str_equals_module_Parent_method(int argc, VALUE *argv, VALUE self)
  {
      VALUE arg;
      Parent_Shadow *shadow;

      rb_scan_args(argc, argv, "1", &arg);

      if (!NIL_P(arg) &&
          rb_obj_is_kind_of(arg, module_String) != Qtrue)
        rb_raise(module_TypeError,
                 "argument arg declared String but passed %s.",
                 STR2CSTR(rb_funcall(
                   rb_funcall(arg, ID_type, 0),
                   ID_to__s, 0)));

      Data_Get_Struct(self, Parent_Shadow, shadow);
      shadow->ruby_str = arg;
      return arg;
  }

